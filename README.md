# DSA-Notes-and-Solutions
Tracking my journey through DSA: problems, solutions, and the insights gained along the way.


---
## 📂 Structure
```
DSA-Notes-and-Solutions
│
├── Arrays
│     ├── problem1.py
│     ├── problem2.py
│     └── README.md   # approach, complexity, pitfalls
│
├── Strings
│   ├── problem1.py
│   └── README.md
│
├── Hashmaps
│   └── ...
│
└── README.md  # main description
```

---
## 📂 Categories Covered
- [ ] Arrays
- [ ] Strings
- [ ] Linked Lists
- [ ] Stacks & Queues
- [ ] Trees
- [ ] Graphs
- [ ] Heaps
- [ ] Dynamic Programming
- [ ] Greedy Algorithms
- [ ] Recursion & Backtracking


---
## 🛠️ Approaches Learned
- [ ] Brute Force
- [ ] Two Pointers
- [ ] Sliding Window
- [ ] Binary Search
- [ ] Hashing / Frequency Counting
- [ ] DFS / BFS Traversal
- [ ] Divide & Conquer
- [ ] Memoization & Tabulation


---
## 📝 Example Solution Format

This section will be expanded once I’ve solved and documented enough problems.

### Planned format:

- Problem name + source
- Difficulty
- Category
- Approach
- Complexity analysis
- Short summary
- Code snippet
- Key learning
- Detailed notes

*(Coming soon — as solutions accumulate.)*

---
## 🎯 Goals

- Solve at least 2–3 problems per category.
- Document approach, complexity, and mistakes for each.
- Gradually shift focus from correctness → optimization → elegant code

---
## 🤝 Contributions / Feedback

This is primarily a personal learning journal. However, suggestions on cleaner approaches or optimization are welcome.
